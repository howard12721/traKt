/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.github.howard12721.trakt.rest.apis

import com.github.howard12721.trakt.rest.infrastructure.*
import com.github.howard12721.trakt.rest.models.*
import io.ktor.client.*
import io.ktor.client.engine.*
import io.ktor.client.request.forms.*
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer

open class UserApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(
        baseUrl = baseUrl,
        httpClientEngine = httpClientEngine,
        httpClientConfig = httpClientConfig,
        jsonBlock = jsonSerializer
    )

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ) : super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * ユーザーにタグを追加
     * 指定したユーザーに指定したタグを追加します。 Webhookユーザーにタグを追加することは出来ません。
     * @param userId ユーザーUUID
     * @param postUserTagRequest  (optional)
     * @return UserTag
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun addUserTag(
        userId: kotlin.String,
        postUserTagRequest: PostUserTagRequest? = null
    ): HttpResponse<UserTag> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postUserTagRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/{userId}/tags".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーのアイコン画像を変更します
     * 指定したユーザーのアイコン画像を変更します。 管理者権限が必要です。
     * @param userId ユーザーUUID
     * @param file アイコン画像(2MBまでのpng, jpeg, gif)
     * @return void
     */
    open suspend fun changeUserIcon(
        userId: kotlin.String,
        file: io.ktor.client.request.forms.FormPart<io.ktor.client.request.forms.InputProvider>
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            formData {
                file?.apply { append(file) }
            }

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/users/{userId}/icon".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return multipartFormRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーのパスワードを変更
     * 指定したユーザーのパスワードを変更します。 管理者権限が必要です。
     * @param userId ユーザーUUID
     * @param putUserPasswordRequest  (optional)
     * @return void
     */
    open suspend fun changeUserPassword(
        userId: kotlin.String,
        putUserPasswordRequest: PutUserPasswordRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = putUserPasswordRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/users/{userId}/password".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーを登録
     * ユーザーを登録します。 管理者権限が必要です。
     * @param postUserRequest  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createUser(postUserRequest: PostUserRequest? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postUserRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザー情報を変更
     * 指定したユーザーの情報を変更します。 管理者権限が必要です。
     * @param userId ユーザーUUID
     * @param patchUserRequest  (optional)
     * @return void
     */
    open suspend fun editUser(userId: kotlin.String, patchUserRequest: PatchUserRequest? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = patchUserRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/users/{userId}".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーのタグを編集
     * 指定したユーザーの指定したタグの状態を変更します。 他人の状態は変更できません。
     * @param userId ユーザーUUID
     * @param tagId タグUUID
     * @param patchUserTagRequest  (optional)
     * @return void
     */
    open suspend fun editUserTag(
        userId: kotlin.String,
        tagId: kotlin.String,
        patchUserTagRequest: PatchUserTagRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = patchUserTagRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/users/{userId}/tags/{tagId}".replace("{" + "userId" + "}", "$userId")
                .replace("{" + "tagId" + "}", "$tagId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderGetDirectMessages(val value: kotlin.String) {

        @SerialName(value = "asc")
        asc("asc"),

        @SerialName(value = "desc")
        desc("desc")

    }

    /**
     * ダイレクトメッセージのリストを取得
     * 指定したユーザーとのダイレクトメッセージのリストを取得します。
     * @param userId ユーザーUUID
     * @param limit 取得する件数 (optional)
     * @param offset 取得するオフセット (optional, default to 0)
     * @param since 取得する時間範囲の開始日時 (optional)
     * @param until 取得する時間範囲の終了日時 (optional)
     * @param inclusive 範囲の端を含めるかどうか (optional, default to false)
     * @param order 昇順か降順か (optional, default to desc)
     * @return kotlin.collections.List<Message>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getDirectMessages(
        userId: kotlin.String,
        limit: kotlin.Int? = null,
        offset: kotlin.Int? = 0,
        since: kotlinx.datetime.Instant? = null,
        until: kotlinx.datetime.Instant? = null,
        inclusive: kotlin.Boolean? = false,
        order: OrderGetDirectMessages? = OrderGetDirectMessages.desc
    ): HttpResponse<kotlin.collections.List<Message>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        since?.apply { localVariableQuery["since"] = listOf("$since") }
        until?.apply { localVariableQuery["until"] = listOf("$until") }
        inclusive?.apply { localVariableQuery["inclusive"] = listOf("$inclusive") }
        order?.apply { localVariableQuery["order"] = listOf("${order.value}") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}/messages".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetDirectMessagesResponse>().map { value }
    }

    @Serializable(GetDirectMessagesResponse.Companion::class)
    private class GetDirectMessagesResponse(val value: List<Message>) {
        companion object : KSerializer<GetDirectMessagesResponse> {
            private val serializer: KSerializer<List<Message>> = serializer<List<Message>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetDirectMessagesResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetDirectMessagesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * ユーザー詳細情報を取得
     * 指定したユーザーの詳細情報を取得します。
     * @param userId ユーザーUUID
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUser(userId: kotlin.String): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * DMチャンネル情報を取得
     * 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。 ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。
     * @param userId
     * @return DMChannel
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserDMChannel(userId: kotlin.String): HttpResponse<DMChannel> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}/dm-channel".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーのアイコン画像を取得
     * 指定したユーザーのアイコン画像を取得します。
     * @param userId ユーザーUUID
     * @return com.github.howard12721.trakt.rest.infrastructure.OctetByteArray
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserIcon(userId: kotlin.String): HttpResponse<com.github.howard12721.trakt.rest.infrastructure.OctetByteArray> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}/icon".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザー統計情報を取得
     * 指定したユーザーの統計情報を取得します。
     * @param userId ユーザーUUID
     * @return UserStats
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserStats(userId: kotlin.String): HttpResponse<UserStats> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}/stats".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーのタグリストを取得
     * 指定したユーザーのタグリストを取得します。
     * @param userId ユーザーUUID
     * @return kotlin.collections.List<UserTag>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserTags(userId: kotlin.String): HttpResponse<kotlin.collections.List<UserTag>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}/tags".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetUserTagsResponse>().map { value }
    }

    @Serializable(GetUserTagsResponse.Companion::class)
    private class GetUserTagsResponse(val value: List<UserTag>) {
        companion object : KSerializer<GetUserTagsResponse> {
            private val serializer: KSerializer<List<UserTag>> = serializer<List<UserTag>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetUserTagsResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetUserTagsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * ユーザーのリストを取得
     * ユーザーのリストを取得します。 &#x60;include-suspended&#x60;を指定しない場合、レスポンスにはユーザーアカウント状態が\&quot;1: 有効\&quot;であるユーザーのみが含まれます。 &#x60;include-suspended&#x60;と&#x60;name&#x60;を同時に指定することはできません。
     * @param includeSuspended アカウントがアクティブでないユーザーを含め、全てのユーザーを取得するかどうか (optional, default to false)
     * @param name 名前が一致するアカウントのみを取得する (optional)
     * @return kotlin.collections.List<User>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUsers(
        includeSuspended: kotlin.Boolean? = false,
        name: kotlin.String? = null
    ): HttpResponse<kotlin.collections.List<User>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeSuspended?.apply { localVariableQuery["include-suspended"] = listOf("$includeSuspended") }
        name?.apply { localVariableQuery["name"] = listOf("$name") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetUsersResponse>().map { value }
    }

    @Serializable(GetUsersResponse.Companion::class)
    private class GetUsersResponse(val value: List<User>) {
        companion object : KSerializer<GetUsersResponse> {
            private val serializer: KSerializer<List<User>> = serializer<List<User>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetUsersResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetUsersResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * ダイレクトメッセージを送信
     * 指定したユーザーにダイレクトメッセージを送信します。
     * @param userId ユーザーUUID
     * @param postMessageRequest  (optional)
     * @return Message
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun postDirectMessage(
        userId: kotlin.String,
        postMessageRequest: PostMessageRequest? = null
    ): HttpResponse<Message> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postMessageRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/{userId}/messages".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ユーザーからタグを削除します
     * 既に存在しないタグを削除しようとした場合は204を返します。
     * @param userId ユーザーUUID
     * @param tagId タグUUID
     * @return void
     */
    open suspend fun removeUserTag(userId: kotlin.String, tagId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/users/{userId}/tags/{tagId}".replace("{" + "userId" + "}", "$userId")
                .replace("{" + "tagId" + "}", "$tagId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
