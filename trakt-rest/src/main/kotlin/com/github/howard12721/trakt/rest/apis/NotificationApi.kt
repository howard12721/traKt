/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.github.howard12721.trakt.rest.apis

import com.github.howard12721.trakt.rest.infrastructure.*
import com.github.howard12721.trakt.rest.models.*
import io.ktor.client.*
import io.ktor.client.engine.*
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer

open class NotificationApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(
        baseUrl = baseUrl,
        httpClientEngine = httpClientEngine,
        httpClientConfig = httpClientConfig,
        jsonBlock = jsonSerializer
    )

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ) : super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * チャンネルの通知購読者を編集
     * 指定したチャンネルの通知購読者を編集します。 リクエストに含めなかったユーザーの通知購読状態は変更しません。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID
     * @param patchChannelSubscribersRequest  (optional)
     * @return void
     */
    open suspend fun editChannelSubscribers(
        channelId: kotlin.String,
        patchChannelSubscribersRequest: PatchChannelSubscribersRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = patchChannelSubscribersRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PATCH,
            "/channels/{channelId}/subscribers".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * チャンネルの通知購読者のリストを取得
     * 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。
     * @param channelId チャンネルUUID
     * @return kotlin.collections.List<kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getChannelSubscribers(channelId: kotlin.String): HttpResponse<kotlin.collections.List<kotlin.String>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/channels/{channelId}/subscribers".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetChannelSubscribersResponse>().map { value }
    }

    @Serializable(GetChannelSubscribersResponse.Companion::class)
    private class GetChannelSubscribersResponse(val value: List<kotlin.String>) {
        companion object : KSerializer<GetChannelSubscribersResponse> {
            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetChannelSubscribersResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetChannelSubscribersResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 自分のチャンネル購読状態を取得
     * 自身のチャンネル購読状態を取得します。
     * @return kotlin.collections.List<UserSubscribeState>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMyChannelSubscriptions(): HttpResponse<kotlin.collections.List<UserSubscribeState>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/subscriptions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetMyChannelSubscriptionsResponse>().map { value }
    }

    @Serializable(GetMyChannelSubscriptionsResponse.Companion::class)
    private class GetMyChannelSubscriptionsResponse(val value: List<UserSubscribeState>) {
        companion object : KSerializer<GetMyChannelSubscriptionsResponse> {
            private val serializer: KSerializer<List<UserSubscribeState>> = serializer<List<UserSubscribeState>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetMyChannelSubscriptionsResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) =
                GetMyChannelSubscriptionsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 未読チャンネルを取得
     * 自分が現在未読のチャンネルの未読情報を取得します。
     * @return kotlin.collections.List<UnreadChannel>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMyUnreadChannels(): HttpResponse<kotlin.collections.List<UnreadChannel>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/unread",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetMyUnreadChannelsResponse>().map { value }
    }

    @Serializable(GetMyUnreadChannelsResponse.Companion::class)
    private class GetMyUnreadChannelsResponse(val value: List<UnreadChannel>) {
        companion object : KSerializer<GetMyUnreadChannelsResponse> {
            private val serializer: KSerializer<List<UnreadChannel>> = serializer<List<UnreadChannel>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetMyUnreadChannelsResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetMyUnreadChannelsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * 自身のチャンネル閲覧状態一覧を取得
     * 自身のチャンネル閲覧状態一覧を取得します。
     * @return kotlin.collections.List<MyChannelViewState>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMyViewStates(): HttpResponse<kotlin.collections.List<MyChannelViewState>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/me/view-states",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetMyViewStatesResponse>().map { value }
    }

    @Serializable(GetMyViewStatesResponse.Companion::class)
    private class GetMyViewStatesResponse(val value: List<MyChannelViewState>) {
        companion object : KSerializer<GetMyViewStatesResponse> {
            private val serializer: KSerializer<List<MyChannelViewState>> = serializer<List<MyChannelViewState>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetMyViewStatesResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetMyViewStatesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * チャンネルを既読にする
     * 自分が未読のチャンネルを既読にします。
     * @param channelId チャンネルUUID
     * @return void
     */
    open suspend fun readChannel(channelId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/users/me/unread/{channelId}".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * FCMデバイスを登録
     * 自身のFCMデバイスを登録します。
     * @param postMyFCMDeviceRequest  (optional)
     * @return void
     */
    open suspend fun registerFCMDevice(postMyFCMDeviceRequest: PostMyFCMDeviceRequest? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postMyFCMDeviceRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/me/fcm-device",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * チャンネル購読レベルを設定
     * 自身の指定したチャンネルの購読レベルを設定します。
     * @param channelId チャンネルUUID
     * @param putChannelSubscribeLevelRequest  (optional)
     * @return void
     */
    open suspend fun setChannelSubscribeLevel(
        channelId: kotlin.String,
        putChannelSubscribeLevelRequest: PutChannelSubscribeLevelRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = putChannelSubscribeLevelRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/users/me/subscriptions/{channelId}".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * チャンネルの通知購読者を設定
     * 指定したチャンネルの通知購読者を設定します。 リクエストに含めなかったユーザーの通知購読状態はオフになります。 また、存在しないユーザーを指定した場合は無視されます。
     * @param channelId チャンネルUUID
     * @param putChannelSubscribersRequest  (optional)
     * @return void
     */
    open suspend fun setChannelSubscribers(
        channelId: kotlin.String,
        putChannelSubscribersRequest: PutChannelSubscribersRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = putChannelSubscribersRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/channels/{channelId}/subscribers".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * WebSocket通知ストリームに接続します
     * # WebSocketプロトコル ## 送信 &#x60;コマンド:引数1:引数2:...&#x60;のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。 ### &#x60;viewstate&#x60;コマンド このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。 現時点では1つのセッションに対して1つのチャンネルしか設定できない。  &#x60;viewstate:{チャンネルID}:{閲覧状態}&#x60; + チャンネルID: 対象のチャンネルID + 閲覧状態: &#x60;none&#x60;, &#x60;monitoring&#x60;, &#x60;editing&#x60;  最初の&#x60;viewstate&#x60;コマンドを送る前、または&#x60;viewstate:null&#x60;, &#x60;viewstate:&#x60;を送信した後は、このセッションはどこのチャンネルも見ていないことになる。  ### &#x60;rtcstate&#x60;コマンド 自分のWebRTC状態を変更する。 他のコネクションが既に状態を保持している場合、変更することができません。  &#x60;rtcstate:{チャンネルID}:({状態}:{セッションID})*&#x60;  コネクションが切断された場合、自分のWebRTC状態はリセットされます。  ### &#x60;timeline_streaming&#x60;コマンド 全てのパブリックチャンネルの&#x60;MESSAGE_CREATED&#x60;イベントを受け取るかどうかを設定する。 初期状態は&#x60;off&#x60;です。  &#x60;timeline_streaming:(on|off|true|false)&#x60;  ## 受信 TextMessageとして各種イベントが&#x60;type&#x60;と&#x60;body&#x60;を持つJSONとして非同期に送られます。  例: &#x60;&#x60;&#x60;json {\&quot;type\&quot;:\&quot;USER_ONLINE\&quot;,\&quot;body\&quot;:{\&quot;id\&quot;:\&quot;7dd8e07f-7f5d-4331-9176-b56a4299768b\&quot;}} &#x60;&#x60;&#x60;  ## イベント一覧  ### &#x60;USER_JOINED&#x60; ユーザーが新規登録された。  対象: 全員  + &#x60;id&#x60;: 登録されたユーザーのId  ### &#x60;USER_UPDATED&#x60; ユーザーの情報が更新された。  対象: 全員  + &#x60;id&#x60;: 情報が更新されたユーザーのId  ### &#x60;USER_TAGS_UPDATED&#x60; ユーザーのタグが更新された。  対象: 全員  + &#x60;id&#x60;: タグが更新されたユーザーのId + &#x60;tag_id&#x60;: 更新されたタグのId  ### &#x60;USER_ICON_UPDATED&#x60; ユーザーのアイコンが更新された。  対象: 全員  + &#x60;id&#x60;: アイコンが更新されたユーザーのId  ### &#x60;USER_WEBRTC_STATE_CHANGED&#x60; ユーザーのWebRTCの状態が変化した  対象: 全員  + &#x60;user_id&#x60;: 変更があったユーザーのId + &#x60;channel_id&#x60;: ユーザーの変更後の接続チャンネルのId + &#x60;sessions&#x60;: ユーザーの変更後の状態(配列)   + &#x60;state&#x60;: 状態   + &#x60;sessionId&#x60;: セッションID  ### &#x60;USER_VIEWSTATE_CHANGED&#x60; ユーザーのチャンネルの閲覧状態が変化した  対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て  + &#x60;view_states&#x60;: 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)   + &#x60;key&#x60;: WSセッションの識別子   + &#x60;channel_id&#x60;: 閲覧しているチャンネルId   + &#x60;state&#x60;: 閲覧状態  ### &#x60;USER_ONLINE&#x60; ユーザーがオンラインになった。  対象: 全員  + &#x60;id&#x60;: オンラインになったユーザーのId  ### &#x60;USER_OFFLINE&#x60; ユーザーがオフラインになった。  対象: 全員  + &#x60;id&#x60;: オフラインになったユーザーのId  ### &#x60;USER_GROUP_CREATED&#x60; ユーザーグループが作成された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_UPDATED&#x60; ユーザーグループが更新された  対象: 全員  + &#x60;id&#x60;: 作成されたユーザーグループのId  ### &#x60;USER_GROUP_DELETED&#x60; ユーザーグループが削除された  対象: 全員  + &#x60;id&#x60;: 削除されたユーザーグループのId  ### &#x60;CHANNEL_CREATED&#x60; チャンネルが新規作成された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 作成されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_UPDATED&#x60; チャンネルの情報が変更された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 変更があったチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_DELETED&#x60; チャンネルが削除された。  対象: 該当チャンネルを閲覧可能な全員  + &#x60;id&#x60;: 削除されたチャンネルのId + &#x60;dm_user_id&#x60;: (DMの場合のみ) DM相手のユーザーId  ### &#x60;CHANNEL_STARED&#x60; 自分がチャンネルをスターした。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_UNSTARED&#x60; 自分がチャンネルのスターを解除した。  対象: 自分  + &#x60;id&#x60;: スターしたチャンネルのId  ### &#x60;CHANNEL_VIEWERS_CHANGED&#x60; チャンネルの閲覧者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId + &#x60;viewers&#x60;: 変化後の閲覧者(配列)   + &#x60;userId&#x60;: ユーザーId   + &#x60;state&#x60;: 閲覧状態   + &#x60;updatedAt&#x60;: 閲覧状態の更新日時  ### &#x60;CHANNEL_SUBSCRIBERS_CHANGED&#x60; チャンネルの購読者が変化した。  対象: 該当チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 変化したチャンネルのId  ### &#x60;MESSAGE_CREATED&#x60; メッセージが投稿された。  対象: 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー  + &#x60;id&#x60;: 投稿されたメッセージのId + &#x60;is_citing&#x60;: 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか  ### &#x60;MESSAGE_UPDATED&#x60; メッセージが更新された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 更新されたメッセージのId  ### &#x60;MESSAGE_DELETED&#x60; メッセージが削除された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;id&#x60;: 削除されたメッセージのId  ### &#x60;MESSAGE_STAMPED&#x60; メッセージにスタンプが押された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId + &#x60;count&#x60;: そのユーザーが押した数 + &#x60;created_at&#x60;: そのユーザーがそのスタンプをそのメッセージに最初に押した日時  ### &#x60;MESSAGE_UNSTAMPED&#x60; メッセージからスタンプが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: メッセージId + &#x60;user_id&#x60;: スタンプを押したユーザーのId + &#x60;stamp_id&#x60;: スタンプのId  ### &#x60;MESSAGE_PINNED&#x60; メッセージがピン留めされた。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンされたメッセージのID + &#x60;channel_id&#x60;: ピンされたメッセージのチャンネルID  ### &#x60;MESSAGE_UNPINNED&#x60; ピン留めされたメッセージのピンが外された。  対象: 投稿チャンネルを閲覧しているユーザー  + &#x60;message_id&#x60;: ピンが外されたメッセージのID + &#x60;channel_id&#x60;: ピンが外されたメッセージのチャンネルID  ### &#x60;MESSAGE_READ&#x60; 自分があるチャンネルのメッセージを読んだ。  対象: 自分  + &#x60;id&#x60;: 読んだチャンネルId  ### &#x60;STAMP_CREATED&#x60; スタンプが新しく追加された。  対象: 全員  + &#x60;id&#x60;: 作成されたスタンプのId  ### &#x60;STAMP_UPDATED&#x60; スタンプが修正された。  対象: 全員  + &#x60;id&#x60;: 修正されたスタンプのId  ### &#x60;STAMP_DELETED&#x60; スタンプが削除された。  対象: 全員  + &#x60;id&#x60;: 削除されたスタンプのId  ### &#x60;STAMP_PALETTE_CREATED&#x60; スタンプパレットが新しく追加された。  対象: 自分  + &#x60;id&#x60;: 作成されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_UPDATED&#x60; スタンプパレットが修正された。  対象: 自分  + &#x60;id&#x60;: 修正されたスタンプパレットのId  ### &#x60;STAMP_PALETTE_DELETED&#x60; スタンプパレットが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたスタンプパレットのId  ### &#x60;CLIP_FOLDER_CREATED&#x60; クリップフォルダーが作成された。  対象：自分  + &#x60;id&#x60;: 作成されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_UPDATED&#x60; クリップフォルダーが修正された。  対象: 自分  + &#x60;id&#x60;: 更新されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_DELETED&#x60; クリップフォルダーが削除された。  対象: 自分  + &#x60;id&#x60;: 削除されたクリップフォルダーのId  ### &#x60;CLIP_FOLDER_MESSAGE_DELETED&#x60; クリップフォルダーからメッセージが除外された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが除外されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーから除外されたメッセージのId  ### &#x60;CLIP_FOLDER_MESSAGE_ADDED&#x60; クリップフォルダーにメッセージが追加された。  対象: 自分  + &#x60;folder_id&#x60;: メッセージが追加されたクリップフォルダーのId + &#x60;message_id&#x60;: クリップフォルダーに追加されたメッセージのId  ### &#x60;QALL_ROOM_STATE_CHANGED&#x60; ルーム状態が変更された。  対象: 全員  + &#x60;room_id&#x60;: 変更されたルームのId + &#x60;state&#x60;: 変更後のルーム状態   + &#x60;roomId&#x60;: ルームのID   + &#x60;participants&#x60;: ルーム内の参加者(配列)     + &#x60;identity&#x60;: ユーザーID_RandomUUID     + &#x60;name&#x60;: 表示名     + &#x60;joinedAt&#x60;: 参加した時刻     + &#x60;attributes&#x60;: ユーザーに関連付けられたカスタム属性     + &#x60;canPublish&#x60;: 発言権限   + &#x60;isWebinar&#x60;: ウェビナールームかどうか   + &#x60;metadata&#x60;: ルームに関連付けられたカスタム属性  ### &#x60;QALL_SOUNDBOARD_ITEM_CREATED&#x60; サウンドボードアイテムが作成された。  対象: 全員  + &#x60;sound_id&#x60;: 作成されたサウンドのId + &#x60;name&#x60;: サウンド名 + &#x60;creator_id&#x60;: 作成者のId  ### &#x60;QALL_SOUNDBOARD_ITEM_DELETED&#x60; サウンドボードアイテムが削除された。  対象: 全員  + &#x60;sound_id&#x60;: 削除されたサウンドのId
     * @return void
     */
    open suspend fun ws(): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/ws",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
