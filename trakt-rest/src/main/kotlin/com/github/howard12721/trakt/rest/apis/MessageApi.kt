/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.github.howard12721.trakt.rest.apis

import com.github.howard12721.trakt.rest.infrastructure.*
import com.github.howard12721.trakt.rest.models.*
import io.ktor.client.*
import io.ktor.client.engine.*
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlinx.serialization.json.Json
import kotlinx.serialization.serializer

open class MessageApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(
        baseUrl = baseUrl,
        httpClientEngine = httpClientEngine,
        httpClientConfig = httpClientConfig,
        jsonBlock = jsonSerializer
    )

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ) : super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * スタンプを押す
     * 指定したメッセージに指定したスタンプを押します。
     * @param messageId メッセージUUID
     * @param stampId スタンプUUID
     * @param postMessageStampRequest  (optional)
     * @return void
     */
    open suspend fun addMessageStamp(
        messageId: kotlin.String,
        stampId: kotlin.String,
        postMessageStampRequest: PostMessageStampRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postMessageStampRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/messages/{messageId}/stamps/{stampId}".replace("{" + "messageId" + "}", "$messageId")
                .replace("{" + "stampId" + "}", "$stampId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ピン留めする
     * 指定したメッセージをピン留めします。 アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。
     * @param messageId メッセージUUID
     * @return MessagePin
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createPin(messageId: kotlin.String): HttpResponse<MessagePin> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/messages/{messageId}/pin".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * メッセージを削除
     * 指定したメッセージを削除します。 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
     * @param messageId メッセージUUID
     * @return void
     */
    open suspend fun deleteMessage(messageId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/messages/{messageId}".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * メッセージを編集
     * 指定したメッセージを編集します。 自身が投稿したメッセージのみ編集することができます。 アーカイブされているチャンネルのメッセージを編集することは出来ません。
     * @param messageId メッセージUUID
     * @param postMessageRequest  (optional)
     * @return void
     */
    open suspend fun editMessage(
        messageId: kotlin.String,
        postMessageRequest: PostMessageRequest? = null
    ): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postMessageRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/messages/{messageId}".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderGetDirectMessages(val value: kotlin.String) {

        @SerialName(value = "asc")
        asc("asc"),

        @SerialName(value = "desc")
        desc("desc")

    }

    /**
     * ダイレクトメッセージのリストを取得
     * 指定したユーザーとのダイレクトメッセージのリストを取得します。
     * @param userId ユーザーUUID
     * @param limit 取得する件数 (optional)
     * @param offset 取得するオフセット (optional, default to 0)
     * @param since 取得する時間範囲の開始日時 (optional)
     * @param until 取得する時間範囲の終了日時 (optional)
     * @param inclusive 範囲の端を含めるかどうか (optional, default to false)
     * @param order 昇順か降順か (optional, default to desc)
     * @return kotlin.collections.List<Message>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getDirectMessages(
        userId: kotlin.String,
        limit: kotlin.Int? = null,
        offset: kotlin.Int? = 0,
        since: kotlinx.datetime.Instant? = null,
        until: kotlinx.datetime.Instant? = null,
        inclusive: kotlin.Boolean? = false,
        order: OrderGetDirectMessages? = OrderGetDirectMessages.desc
    ): HttpResponse<kotlin.collections.List<Message>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        since?.apply { localVariableQuery["since"] = listOf("$since") }
        until?.apply { localVariableQuery["until"] = listOf("$until") }
        inclusive?.apply { localVariableQuery["inclusive"] = listOf("$inclusive") }
        order?.apply { localVariableQuery["order"] = listOf("${order.value}") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/users/{userId}/messages".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetDirectMessagesResponse>().map { value }
    }

    @Serializable(GetDirectMessagesResponse.Companion::class)
    private class GetDirectMessagesResponse(val value: List<Message>) {
        companion object : KSerializer<GetDirectMessagesResponse> {
            private val serializer: KSerializer<List<Message>> = serializer<List<Message>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetDirectMessagesResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetDirectMessagesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * メッセージを取得
     * 指定したメッセージを取得します。
     * @param messageId メッセージUUID
     * @return Message
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMessage(messageId: kotlin.String): HttpResponse<Message> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/messages/{messageId}".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * 自分のクリップを取得
     * 対象のメッセージの自分のクリップの一覧を返します。
     * @param messageId メッセージUUID
     * @return kotlin.collections.List<MessageClip>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMessageClips(messageId: kotlin.String): HttpResponse<kotlin.collections.List<MessageClip>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/messages/{messageId}/clips".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetMessageClipsResponse>().map { value }
    }

    @Serializable(GetMessageClipsResponse.Companion::class)
    private class GetMessageClipsResponse(val value: List<MessageClip>) {
        companion object : KSerializer<GetMessageClipsResponse> {
            private val serializer: KSerializer<List<MessageClip>> = serializer<List<MessageClip>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetMessageClipsResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetMessageClipsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * メッセージのスタンプリストを取得
     * 指定したメッセージに押されているスタンプのリストを取得します。
     * @param messageId メッセージUUID
     * @return kotlin.collections.List<MessageStamp>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMessageStamps(messageId: kotlin.String): HttpResponse<kotlin.collections.List<MessageStamp>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/messages/{messageId}/stamps".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetMessageStampsResponse>().map { value }
    }

    @Serializable(GetMessageStampsResponse.Companion::class)
    private class GetMessageStampsResponse(val value: List<MessageStamp>) {
        companion object : KSerializer<GetMessageStampsResponse> {
            private val serializer: KSerializer<List<MessageStamp>> = serializer<List<MessageStamp>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetMessageStampsResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetMessageStampsResponse(serializer.deserialize(decoder))
        }
    }


    /**
     * enum for parameter order
     */
    @Serializable
    enum class OrderGetMessages(val value: kotlin.String) {

        @SerialName(value = "asc")
        asc("asc"),

        @SerialName(value = "desc")
        desc("desc")

    }

    /**
     * チャンネルメッセージのリストを取得
     * 指定したチャンネルのメッセージのリストを取得します。
     * @param channelId チャンネルUUID
     * @param limit 取得する件数 (optional)
     * @param offset 取得するオフセット (optional, default to 0)
     * @param since 取得する時間範囲の開始日時 (optional)
     * @param until 取得する時間範囲の終了日時 (optional)
     * @param inclusive 範囲の端を含めるかどうか (optional, default to false)
     * @param order 昇順か降順か (optional, default to desc)
     * @return kotlin.collections.List<Message>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMessages(
        channelId: kotlin.String,
        limit: kotlin.Int? = null,
        offset: kotlin.Int? = 0,
        since: kotlinx.datetime.Instant? = null,
        until: kotlinx.datetime.Instant? = null,
        inclusive: kotlin.Boolean? = false,
        order: OrderGetMessages? = OrderGetMessages.desc
    ): HttpResponse<kotlin.collections.List<Message>> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        since?.apply { localVariableQuery["since"] = listOf("$since") }
        until?.apply { localVariableQuery["until"] = listOf("$until") }
        inclusive?.apply { localVariableQuery["inclusive"] = listOf("$inclusive") }
        order?.apply { localVariableQuery["order"] = listOf("${order.value}") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/channels/{channelId}/messages".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetMessagesResponse>().map { value }
    }

    @Serializable(GetMessagesResponse.Companion::class)
    private class GetMessagesResponse(val value: List<Message>) {
        companion object : KSerializer<GetMessagesResponse> {
            private val serializer: KSerializer<List<Message>> = serializer<List<Message>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetMessagesResponse) =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder) = GetMessagesResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * ピン留めを取得
     * 指定したメッセージのピン留め情報を取得します。
     * @param messageId メッセージUUID
     * @return MessagePin
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getPin(messageId: kotlin.String): HttpResponse<MessagePin> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/messages/{messageId}/pin".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ダイレクトメッセージを送信
     * 指定したユーザーにダイレクトメッセージを送信します。
     * @param userId ユーザーUUID
     * @param postMessageRequest  (optional)
     * @return Message
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun postDirectMessage(
        userId: kotlin.String,
        postMessageRequest: PostMessageRequest? = null
    ): HttpResponse<Message> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postMessageRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/users/{userId}/messages".replace("{" + "userId" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * チャンネルにメッセージを投稿
     * 指定したチャンネルにメッセージを投稿します。 embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。 アーカイブされているチャンネルに投稿することはできません。
     * @param channelId チャンネルUUID
     * @param postMessageRequest  (optional)
     * @return Message
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun postMessage(
        channelId: kotlin.String,
        postMessageRequest: PostMessageRequest? = null
    ): HttpResponse<Message> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody = postMessageRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/channels/{channelId}/messages".replace("{" + "channelId" + "}", "$channelId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * スタンプを消す
     * 指定したメッセージから指定した自身が押したスタンプを削除します。
     * @param messageId メッセージUUID
     * @param stampId スタンプUUID
     * @return void
     */
    open suspend fun removeMessageStamp(messageId: kotlin.String, stampId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/messages/{messageId}/stamps/{stampId}".replace("{" + "messageId" + "}", "$messageId")
                .replace("{" + "stampId" + "}", "$stampId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * ピン留めを外す
     * 指定したメッセージのピン留めを外します。
     * @param messageId メッセージUUID
     * @return void
     */
    open suspend fun removePin(messageId: kotlin.String): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/messages/{messageId}/pin".replace("{" + "messageId" + "}", "$messageId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * enum for parameter sort
     */
    @Serializable
    enum class SortSearchMessages(val value: kotlin.String) {

        @SerialName(value = "createdAt")
        createdAt("createdAt"),

        @SerialName(value = "-createdAt")
        MinusCreatedAt("-createdAt"),

        @SerialName(value = "updatedAt")
        updatedAt("updatedAt"),

        @SerialName(value = "-updatedAt")
        MinusUpdatedAt("-updatedAt")

    }

    /**
     * メッセージを検索
     * メッセージを検索します。
     * @param word 検索ワード Simple-Query-String-Syntaxをパースして検索します  (optional)
     * @param after 投稿日時が指定日時より後 (optional)
     * @param before 投稿日時が指定日時より前 (optional)
     * @param `in` メッセージが投稿されたチャンネル (optional)
     * @param to メンションされたユーザー (optional)
     * @param from メッセージを投稿したユーザー (optional)
     * @param citation 引用しているメッセージ (optional)
     * @param bot メッセージを投稿したユーザーがBotかどうか (optional)
     * @param hasURL メッセージがURLを含むか (optional)
     * @param hasAttachments メッセージが添付ファイルを含むか (optional)
     * @param hasImage メッセージが画像を含むか (optional)
     * @param hasVideo メッセージが動画を含むか (optional)
     * @param hasAudio メッセージが音声ファイルを含むか (optional)
     * @param limit 検索結果から取得するメッセージの最大件数 (optional)
     * @param offset 検索結果から取得するメッセージのオフセット (optional)
     * @param sort ソート順 (作成日時が新しい &#x60;createdAt&#x60;, 作成日時が古い &#x60;-createdAt&#x60;, 更新日時が新しい &#x60;updatedAt&#x60;, 更新日時が古い &#x60;-updatedAt&#x60;) (optional, default to -createdAt)
     * @return MessageSearchResult
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun searchMessages(
        word: kotlin.String? = null,
        after: kotlinx.datetime.Instant? = null,
        before: kotlinx.datetime.Instant? = null,
        `in`: kotlin.String? = null,
        to: kotlin.collections.List<kotlin.String>? = null,
        from: kotlin.collections.List<kotlin.String>? = null,
        citation: kotlin.String? = null,
        bot: kotlin.Boolean? = null,
        hasURL: kotlin.Boolean? = null,
        hasAttachments: kotlin.Boolean? = null,
        hasImage: kotlin.Boolean? = null,
        hasVideo: kotlin.Boolean? = null,
        hasAudio: kotlin.Boolean? = null,
        limit: kotlin.Int? = null,
        offset: kotlin.Int? = null,
        sort: SortSearchMessages? = SortSearchMessages.MinusCreatedAt
    ): HttpResponse<MessageSearchResult> {

        val localVariableAuthNames = listOf<String>("OAuth2", "bearerAuth")

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        word?.apply { localVariableQuery["word"] = listOf("$word") }
        after?.apply { localVariableQuery["after"] = listOf("$after") }
        before?.apply { localVariableQuery["before"] = listOf("$before") }
        `in`?.apply { localVariableQuery["in"] = listOf("$`in`") }
        to?.apply { localVariableQuery["to"] = toMultiValue(this, "multi") }
        from?.apply { localVariableQuery["from"] = toMultiValue(this, "multi") }
        citation?.apply { localVariableQuery["citation"] = listOf("$citation") }
        bot?.apply { localVariableQuery["bot"] = listOf("$bot") }
        hasURL?.apply { localVariableQuery["hasURL"] = listOf("$hasURL") }
        hasAttachments?.apply { localVariableQuery["hasAttachments"] = listOf("$hasAttachments") }
        hasImage?.apply { localVariableQuery["hasImage"] = listOf("$hasImage") }
        hasVideo?.apply { localVariableQuery["hasVideo"] = listOf("$hasVideo") }
        hasAudio?.apply { localVariableQuery["hasAudio"] = listOf("$hasAudio") }
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        offset?.apply { localVariableQuery["offset"] = listOf("$offset") }
        sort?.apply { localVariableQuery["sort"] = listOf("${sort.value}") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/messages",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
